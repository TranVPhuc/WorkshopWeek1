[
{
	"uri": "//localhost:1313/3-explantion/3.1-vpc/",
	"title": "Create VPC and configure connectivity ",
	"tags": [],
	"description": "",
	"content": "Create VPC and configure connectivity Create VPC: resource \u0026#34;aws_vpc\u0026#34; \u0026#34;prod-vpc\u0026#34; {\rcidr_block = \u0026#34;10.0.0.0/16\u0026#34;\rtags = {\rName = \u0026#34;production\u0026#34;\r}\r} This code snippet defines a resource \u0026ldquo;aws_vpc\u0026rdquo; named \u0026ldquo;prod-vpc\u0026rdquo;, using the address range 10.0.0.0/16, and tagged with a tag \u0026ldquo;Name\u0026rdquo; having the value \u0026ldquo;production\u0026rdquo;.\nresource \u0026ldquo;aws_vpc\u0026rdquo; \u0026ldquo;prod-vpc\u0026rdquo;: This is a declaration of an aws_vpc resource type, where \u0026ldquo;prod-vpc\u0026rdquo; is the name you assign to this resource. In Terraform, resources can be referenced by this name after they are created.\ncidr_block = \u0026ldquo;10.0.0.0/16\u0026rdquo;: This is an important part to specify the network range of the VPC. The CIDR block is a way to define the range of IP addresses that the VPC will use. In this case, the CIDR block is \u0026ldquo;10.0.0.0/16\u0026rdquo;, meaning the VPC will have available IP addresses ranging from 10.0.0.0 to 10.0.255.255.\ntags = { Name = \u0026ldquo;production\u0026rdquo; }: This is the tags section assigned to the resource. In this case, there is a single tag assigned with key \u0026ldquo;Name\u0026rdquo; and value \u0026ldquo;production\u0026rdquo;. Tags can be used to organize and manage resources in the AWS environment.\nCreate Internet Gateway resource \u0026#34;aws_internet_gateway\u0026#34; \u0026#34;gw\u0026#34; {\rvpc_id = aws_vpc.prod-vpc.id\r} This code snippet defines a resource \u0026ldquo;aws_internet_gateway\u0026rdquo; named \u0026ldquo;gw\u0026rdquo;.\nresource \u0026ldquo;aws_internet_gateway\u0026rdquo; \u0026ldquo;gw\u0026rdquo;: This is a declaration of an aws_internet_gateway resource type, where \u0026ldquo;gw\u0026rdquo; is the name you assign to this resource. Similar to before, you can reference this resource after it is created. vpc_id = aws_vpc.prod-vpc.id: The vpc_id attribute specifies the VPC to which the IGW will be attached. In this case, the IGW will be attached to the VPC identified by referencing the aws_vpc.prod-vpc resource and accessing its id attribute. This ensures that the IGW will be attached to the previously created VPC named \u0026ldquo;prod-vpc\u0026rdquo;. Create Route Table resource \u0026#34;aws_route_table\u0026#34; \u0026#34;prod-route-table\u0026#34; {\rvpc_id = aws_vpc.prod-vpc.id\rroute {\rcidr_block = \u0026#34;0.0.0.0/0\u0026#34;\rgateway_id = aws_internet_gateway.gw.id\r}\rroute {\ripv6_cidr_block = \u0026#34;::/0\u0026#34;\rgateway_id = aws_internet_gateway.gw.id\r}\rtags = {\rName = \u0026#34;Prod\u0026#34;\r}\r} The code snippet creates a route table on AWS and configures routes for the previously created VPC, allowing resources within the VPC to access the Internet.\nresource \u0026ldquo;aws_route_table\u0026rdquo; \u0026ldquo;prod-route-table\u0026rdquo;: This is a declaration of an aws_route_table resource type, where \u0026ldquo;prod-route-table\u0026rdquo; is the name you assign to this resource. vpc_id = aws_vpc.prod-vpc.id: The vpc_id attribute identifies the VPC to which the route table will be applied. In this case, this Route Table is applied to the VPC with the ID identified by referencing the aws_vpc.prod-vpc resource and accessing its id attribute. route { cidr_block = \u0026ldquo;0.0.0.0/0\u0026rdquo; gateway_id = aws_internet_gateway.gw.id }: This configures routes for IPv4 addresses. This route will forward all packets destined for any IP address (CIDR block is \u0026ldquo;0.0.0.0/0\u0026rdquo;) to the previously created Internet Gateway. This allows resources within the VPC to access the Internet. route { ipv6_cidr_block = \u0026ldquo;::/0\u0026rdquo; gateway_id = aws_internet_gateway.gw.id }: This configures routes for IPv6 addresses. Similar to the IPv4 route, this route will also forward all IPv6 packets destined for any IP address (CIDR block is \u0026ldquo;::/0\u0026rdquo;) to the previously created Internet Gateway.llows resources within the VPC to access the Internet. tags = { Name = \u0026ldquo;Prod\u0026rdquo; }: This is the tags section assigned to the route table. In this case, there is a single tag assigned with key \u0026ldquo;Name\u0026rdquo; and value \u0026ldquo;Prod\u0026rdquo;. Khởi tạo subnet resource \u0026#34;aws_subnet\u0026#34; \u0026#34;subnet-1\u0026#34; {\rvpc_id = aws_vpc.prod-vpc.id\rcidr_block = \u0026#34;10.0.1.0/24\u0026#34;\ravailability_zone = \u0026#34;us-east-1a\u0026#34;\rtags = {\rName = \u0026#34;prod-subnet\u0026#34;\r}\r} The code snippet defines a subnet within the previously created VPC. When this code is executed, it will create a subnet within the previously created VPC, with the IP address range \u0026ldquo;10.0.1.0/24\u0026rdquo; and placed in the \u0026ldquo;us-east-1a\u0026rdquo; region.\nresource \u0026ldquo;aws_subnet\u0026rdquo; \u0026ldquo;subnet-1\u0026rdquo;: This is a declaration of an aws_subnet resource type, where subnet-1 is the name you assign to this subnet. vpc_id = aws_vpc.prod-vpc.id: The vpc_id attribute specifies the ID of the VPC to which the subnet will belong. In this case, it is specifying that the subnet will belong to the VPC with the ID identified by referencing the aws_vpc.prod-vpc resource and accessing its id attribute. cidr_block = \u0026ldquo;10.0.1.0/24\u0026rdquo;: The cidr_block attribute defines the IP address range of the subnet. In this case, the subnet will have a range from 10.0.1.0 to 10.0.1.255, with 256 available IP addresses. availability_zone = \u0026ldquo;us-east-1a\u0026rdquo;: The availability_zone attribute specifies the region where the subnet will be created. In this case, the subnet will be created in the \u0026ldquo;us-east-1a\u0026rdquo; region. tags = { Name = \u0026ldquo;prod-subnet\u0026rdquo; }: This is the tags section assigned to the subnet. In this case, there is a single tag assigned with key \u0026ldquo;Name\u0026rdquo; and value \u0026ldquo;prod-subnet\u0026rdquo;. Tags can be used to organize and manage resources in the AWS environment. Linking the subnet with the route table resource \u0026#34;aws_route_table_association\u0026#34; \u0026#34;a\u0026#34; {\rsubnet_id = aws_subnet.subnet-1.id\rroute_table_id = aws_route_table.prod-route-table.id\r} This code snippet associates the subnet \u0026ldquo;subnet-1\u0026rdquo; with the route table \u0026ldquo;prod-route-table\u0026rdquo;. This way, instances launched in the subnet \u0026ldquo;subnet-1\u0026rdquo; will use the routes declared in the \u0026ldquo;prod-route-table\u0026rdquo; to route traffic between the VPC and the internet gateway.\nresource \u0026ldquo;aws_route_table_association\u0026rdquo; \u0026ldquo;a\u0026rdquo;: This is a declaration of a resource of type aws_route_table_association, where \u0026ldquo;a\u0026rdquo; is the name you assign to this resource. subnet_id = aws_subnet.subnet-1.id: The subnet_id attribute specifies the subnet to which this association will apply. In this case, it is specifying that this association applies to the subnet with the ID identified by referencing the aws_subnet.subnet-1 resource and accessing its id attribute. route_table_id = aws_route_table.prod-route-table.id: The route_table_id attribute identifies the Route Table to which this association will apply. In this case, it is specifying that this association will apply to the Route Table with the ID identified by referencing the aws_route_table.prod-route-table resource and accessing its id attribute. "
},
{
	"uri": "//localhost:1313/1-introduce/",
	"title": "Introduction",
	"tags": [],
	"description": "",
	"content": "Giới thiệu Terraform Terraform is an open-source tool used to manage infrastructure as code (IaC). Terraform allows you to define and manage infrastructure resources such as virtual machines, networks, storage, etc., across multiple cloud providers such as AWS, Azure, Google Cloud Platform (GCP), Alibaba Cloud, etc.\nBenefits of Using Terraform:\nAutomation: Terraform helps automate the deployment and management of infrastructure, saving time and minimizing errors caused by manual operations. Consistency: Terraform helps ensure consistency in deploying infrastructure across different environments. Reusability: Terraform allows you to modularize infrastructure and reuse these modules across different projects. Tracking Capability: Terraform helps track the state of infrastructure, making it easy to identify changes that have been made. Nội dung Workflow Provider Resource Module State Now we will go through the most basic concepts of Terraform together.\n"
},
{
	"uri": "//localhost:1313/2-prerequiste/2.1-terraform-install/",
	"title": "Security Group",
	"tags": [],
	"description": "",
	"content": "Security Group Basic Features of Security Group Allow Rules Only: Only Allow rules can be added; Deny rules cannot be added. Separate Rules for Traffic: Separate rules can be specified for outgoing and incoming traffic. Initial Inbound Rules: A newly created Security group starts with no Inbound rules. Initially, the instance won\u0026rsquo;t allow any traffic in, requiring the addition of an Inbound rule to enable access. Default Outbound Rule: By default, the Security group includes an Outbound rule that permits all traffic to leave the instance. This rule can be modified or replaced with specific Outbound rules to control outgoing traffic originating from the instance. If there\u0026rsquo;s no Outbound rule, no traffic is allowed to exit the instance. Stateful Service: Security groups are stateful services, meaning that if incoming traffic is allowed, outgoing traffic is automatically permitted, and vice versa, regardless of the Outbound rule. Instance Communication: Instances can communicate only if they are associated with a Security group that permits connections, or if a Security group associated with the instance contains a rule allowing traffic. The default Security group has default rules allowing all traffic. Association with Network Interfaces: Security groups are associated with network interfaces. After initialization, you can change the Security group assigned to an instance, which will also update the Security group for the corresponding primary network interface. Security Group Rule A Security group rule is created to grant access to traffic entering or leaving an instance. This access can apply to a specific CIDR or to a Security group in the same VPC, or even to a Security group in another VPC connected by peering.\nComponents of Security Group Rule Inbound Rules: These include the source of the traffic and the destination port or port range. The source can be another security group, an IPv4 or IPv6 CIDR range, or an IPv4/IPv6 address. Outbound Rules: These include the destination of the traffic and the destination port or port range. The destination can be another security group, an IPv4 or IPv6 CIDR range, an IPv4/IPv6 address, or a service identified by a prefix (e.g. igw_xxx) in the prefix ID list (where services are identified by the prefix ID - the name and ID of the available service in the region). Standard Protocols: Each protocol has a standard protocol number associated with it. For instance, SSH is associated with port number 22. "
},
{
	"uri": "//localhost:1313/",
	"title": "Start with Amazon VPC and AWS VPN Site-to-Site",
	"tags": [],
	"description": "",
	"content": "Start with Terraform Overview In this article, you will learn the basics and practice with Terraform. Learn the key concepts and features of Terraform. Install Terraform and deploy a Web Server on AWS using Apache2. Content Introduce Terraform Prerequiste Provisioning resources Cleanup "
},
{
	"uri": "//localhost:1313/1-introduce/1.1-workflow/",
	"title": "Workflow",
	"tags": [],
	"description": "",
	"content": "Terraform Workflow The typical workflow of Terraform often includes the following steps::\nDesign: Identify the necessary resources and their relationships. Build directory structure and modules if required.. Initialization: Download and install necessary plugins for the project.. Terraform will create a directory containing the required plugins. Plan: Terraform will compare the current state with the desired state defined in the infrastructure code and display the expected changes. Deployment: Terraform will deploy the planned changes. At this point, Terraform will create, update, or delete resources as well as update the state. State Management: Terraform uses a state file to track the actual state of the infrastructure compared to the configuration code. During the deployment process, this state is updated and securely stored. Verification: After deployment, verify that the deployed resources are functioning as expected. Monitoring and Maintenance: Utilize appropriate monitoring and maintenance tools such as CloudWatch. Adjust: When configuration changes are needed, iterate through the process starting from the design phase or by modifying Terraform configuration files. Clean up: When resources are no longer needed, Terraform will delete the managed resources and update the state. "
},
{
	"uri": "//localhost:1313/2-prerequiste/",
	"title": "Prerequiste",
	"tags": [],
	"description": "",
	"content": "Prerequiste In this article, we will proceed to install Terraform and deploy a Web Server using a Ubuntu virtual machine and apache2. You can download the project zip file here.\nContent Installing Terraform Deloy Web Server ADD AWS Profile "
},
{
	"uri": "//localhost:1313/3-explantion/3.2-sg-nw/",
	"title": "Security Group and Network Interface",
	"tags": [],
	"description": "",
	"content": "Create Security Group và Network Interface Create Security Group\nresource \u0026#34;aws_security_group\u0026#34; \u0026#34;allow_web\u0026#34; {\rname = \u0026#34;allow_web_traffic\u0026#34;\rdescription = \u0026#34;Allow Web inbound traffic\u0026#34;\rvpc_id = aws_vpc.prod-vpc.id\ringress {\rdescription = \u0026#34;HTTPS\u0026#34;\rfrom_port = 443\rto_port = 443\rprotocol = \u0026#34;tcp\u0026#34;\rcidr_blocks = [\u0026#34;0.0.0.0/0\u0026#34;]\r}\ringress {\rdescription = \u0026#34;HTTP\u0026#34;\rfrom_port = 80\rto_port = 80\rprotocol = \u0026#34;tcp\u0026#34;\rcidr_blocks = [\u0026#34;0.0.0.0/0\u0026#34;]\r}\ringress {\rdescription = \u0026#34;SSH\u0026#34;\rfrom_port = 22\rto_port = 22\rprotocol = \u0026#34;tcp\u0026#34;\rcidr_blocks = [\u0026#34;0.0.0.0/0\u0026#34;]\r}\regress {\rfrom_port = 0\rto_port = 0\rprotocol = \u0026#34;-1\u0026#34;\rcidr_blocks = [\u0026#34;0.0.0.0/0\u0026#34;]\r}\rtags = {\rName = \u0026#34;allow_web\u0026#34;\r}\r} The code above creates a security group named \u0026ldquo;allow_web\u0026rdquo; that allows web traffic (HTTPS and HTTP) and SSH to instances associated with this security group. Outbound traffic from the instances is unrestricted.\nresource \u0026ldquo;aws_security_group\u0026rdquo; \u0026ldquo;allow_web\u0026rdquo;: This is a declaration of a resource of type aws_security_group, where \u0026ldquo;allow_web\u0026rdquo; is the name you assign to this security group. name = \u0026ldquo;allow_web_traffic\u0026rdquo;: The name attribute specifies the name of the security group. In this case, the security group is named \u0026ldquo;allow_web_traffic\u0026rdquo;.\ndescription = \u0026ldquo;Allow Web inbound traffic\u0026rdquo;: The description attribute provides a description for the security group. In this case, the description is \u0026ldquo;Allow Web inbound traffic\u0026rdquo;.\nvpc_id = aws_vpc.prod-vpc.id: The vpc_id attribute identifies the VPC to which this security group belongs. In this case, the security group belongs to the VPC with the ID determined by referencing the aws_vpc.prod-vpc resource and accessing its id attribute.\ningress and egress: These blocks define the routing rules (inbound and outbound traffic) for the security group. In this case:\ningress: defines rules for inbound traffic. Three rules are defined here to allow HTTPS traffic (port 443), HTTP traffic (port 80), and SSH traffic (port 22) from any IP address (\u0026ldquo;0.0.0.0/0\u0026rdquo;).\negress: defines rules for outbound traffic. In this case, it allows all outbound traffic to any IP address (\u0026ldquo;0.0.0.0/0\u0026rdquo;).\ntags = { Name = \u0026ldquo;allow_web\u0026rdquo; }: This is the tags section where labels are assigned to the security group. In this case, a single tag is assigned with the key \u0026ldquo;Name\u0026rdquo; and the value \u0026ldquo;allow_web\u0026rdquo;. Tags can be used to organize and manage resources in the AWS environment.\nCreate NetWork Interface\nresource \u0026#34;aws_network_interface\u0026#34; \u0026#34;web-server-nic\u0026#34; {\rsubnet_id = aws_subnet.subnet-1.id\rprivate_ips = [\u0026#34;10.0.1.50\u0026#34;]\rsecurity_groups = [aws_security_group.allow_web.id]\r} resource \u0026ldquo;aws_network_interface\u0026rdquo; \u0026ldquo;web-server-nic\u0026rdquo;: This is a declaration of a resource of type aws_network_interface, where \u0026ldquo;web-server-nic\u0026rdquo; is the name you assign to this Network Interface (NIC). subnet_id = aws_subnet.subnet-1.id: The subnet_id attribute identifies the subnet that the NIC will be attached to. In this case, it specifies that the NIC will be attached to the subnet with the ID determined by referencing the aws_subnet.subnet-1 resource and accessing its id attribute. private_ips = [\u0026ldquo;10.0.1.50\u0026rdquo;]: The private_ips attribute specifies the private IP address for the NIC. In this case, the NIC will have the IP address \u0026ldquo;10.0.1.50\u0026rdquo; within the specified subnet. security_groups = [aws_security_group.allow_web.id]: The security_groups attribute identifies the security groups that the NIC will apply. In this case, the NIC will apply the rules from the security group with the ID determined by referencing the aws_security_group.allow_web resource and accessing its id attribute. This ensures that the NIC will adhere to the traffic rules defined in this security group. Gán Elastic IP vào Network Interface\nresource \u0026#34;aws_eip\u0026#34; \u0026#34;one\u0026#34; {\rdomain = \u0026#34;vpc\u0026#34;\rnetwork_interface = aws_network_interface.web-server-nic.id\rassociate_with_private_ip = \u0026#34;10.0.1.50\u0026#34;\rdepends_on = [ aws_internet_gateway.gw,aws_instance.web-server-instance ]\r}\routput \u0026#34;server_public_ip\u0026#34; {\rvalue = aws_eip.one.public_ip\r} After applying this Terraform configuration, you can access the public IP address associated with Elastic IP \u0026ldquo;one\u0026rdquo; using the output variable server_public_ip.\ndomain: Set to \u0026ldquo;vpc\u0026rdquo;, indicating that the EIP is intended for the VPC environment. network_interface: Specifies the ID of the current Network Interface (aws_network_interface.web-server-nic.id). The EIP will be associated with this Network Interface. associate_with_private_ip: Specifies the private IP address (10.0.1.50) within the VPC to which the EIP will be associated. depends_on: Ensures that the EIP (aws_eip.one) is created only after the Internet Gateway (aws_internet_gateway.gw) and Instance (aws_instance.web-server-instance) are created. value: References the public_ip attribute of the aws_eip.one resource. This attribute will capture the public IP address assigned to the EIP and display it in the Terminal. "
},
{
	"uri": "//localhost:1313/1-introduce/1.2-provider/",
	"title": "Terraform Provider",
	"tags": [],
	"description": "",
	"content": "Terraform Provider Terraform Provider is a software acting as a bridge between Terraform and a specific platform, such as Amazon Web Services (AWS), Microsoft Azure, Google Cloud Platform, etc. It allows Terraform to interact with the APIs of the targeted platform to create, manage, and update resources. Main Functions:\nResource Creation: The Terraform provider offers functions and APIs to create new resources on the specific platform. Resource Creation: The Terraform provider offers functions and APIs to create new resources on the specific platform. State Management: Tracks the state of resources, aiding Terraform in determining necessary changes.. Examples:\nAWS Provider: Enables Terraform to interact with AWS services such as EC2, S3, RDS, etc. Azure Provider: Allows Terraform to interact with Azure services such as VMs, Storage, SQL Database, etc. GCP Provider: Permits Terraform to interact with GCP services such as Compute Engine, Cloud Storage, Cloud SQL, etc. "
},
{
	"uri": "//localhost:1313/2-prerequiste/2.2-ws-structure/",
	"title": "Web Server Structure",
	"tags": [],
	"description": "",
	"content": "Web Server Structure The structure of a web server can be divided into the following basic components:\nServer Hardware: Server: A computer that runs continuously to serve web services. Network Connectivity: To connect to the internet or an internal network. Server Software: Operating System: Typically variants of Linux (such as Ubuntu, CentOS) or Windows Server. Web Server Software: Software running on the server to handle HTTP requests. Apache, Nginx, Microsoft IIS are common examples. Ứng dụng và dữ liêu: Web Application: The source code of the website or web application, often written in languages such as HTML, CSS, JavaScript, and backend languages like PHP, Python, Ruby, or Node.js. Data: Databases are commonly used to store data for web applications, such as MySQL, PostgreSQL, MongoDB. The operation of a web server can be outlined as follows: Request Reception (Request Handling): The web server listens on a specific port (typically port 80 for HTTP or 443 for HTTPS). When an HTTP request is sent, the web server receives this request via the TCP/IP protocol. Request Processing: The web server identifies the type of request (GET, POST, PUT, DELETE) and parses the Uniform Resource Identifier (URI). Based on the URI and configuration rules, the web server determines what to do with the request (e.g., access a file, execute source code, send back a previously stored webpage) Tạo và gửi phản hồi (Response Generation): Based on the request type and content, the web server generates an HTTP response. This response could be an HTML page, a file, or a status code The response is sent back to the client via the TCP/IP protocol. Kết thúc kết nối (Connection Closure): After the response is sent, the TCP/IP connection may be closed or kept alive to support keep-alive (keeping the connection open to reduce latency in establishing new connections). Ghi log và theo dõi (Logging and Monitoring): The web server may log information about processed requests and server activity for analysis and performance monitoring purposes. "
},
{
	"uri": "//localhost:1313/3-explantion/3.3-ec2/",
	"title": "Configure EC2 instance",
	"tags": [],
	"description": "",
	"content": "Configure EC2 Instance resource \u0026#34;aws_instance\u0026#34; \u0026#34;web-server-instance\u0026#34; {\rami = \u0026#34;ami-085925f297f89fce1\u0026#34;\rinstance_type = \u0026#34;t2.micro\u0026#34;\ravailability_zone = \u0026#34;us-east-1a\u0026#34;\rkey_name = \u0026#34;web-server-key\u0026#34;\rnetwork_interface {\rdevice_index = 0\rnetwork_interface_id = aws_network_interface.web-server-nic.id\r}\ruser_data = \u0026lt;\u0026lt;-EOF\r#!/bin/bash\rsudo apt update -y\rsudo apt install apache2 -y\rsudo systemctl start apache2\rsudo bash -c \u0026#39;echo your very first web server \u0026gt; /var/www/html/index.html\u0026#39;\rEOF\rtags = {\rName = \u0026#34;web-server\u0026#34;\r}\r} This Terraform code sets up a web server on AWS EC2 with a basic Apache web server configuration. By running this configuration, Terraform will provision the resources and launch the server with the specified configuratio\nresource \u0026ldquo;aws_instance\u0026rdquo; \u0026ldquo;web-server-instance\u0026rdquo;: defines a resource of type aws_instance and assigns it the name web-server-instance. This name will be used to reference this specific server in your Terraform configuration.\nami = \u0026ldquo;ami-085925f297f89fce1\u0026rdquo;: This line specifies the Amazon Machine Image (AMI) to use for launching the server. You can find different AMIs in the AWS Marketplace or create your own custom AMI.\ninstance_type = \u0026ldquo;t2.micro\u0026rdquo;: This line specifies the instance type that will be launched. In this case, it is t2.micro.\navailability_zone = \u0026ldquo;us-east-1a\u0026rdquo;: This line specifies the Availability Zone (AZ) where the instance will be launched.\nnetwork_interface { \u0026hellip; }: This block defines the network interface for the server. Terraform seems to be referencing an existing resource named aws_network_interface.web-server-nic.\nuser_data = \u0026laquo;-EOF \u0026hellip; EOF: This defines a set of commands to be executed on the server during the first boot. The script uses #!/bin/bash to perform the following actions:\nsudo apt update -y: Updates the package list for the package manager. sudo apt install apache2 -y: Installs the Apache web server software. sudo systemctl start apache2: Starts the Apache web server service. sudo bash -c \u0026rsquo;echo your very first web server \u0026gt; /var/www/html/index.html\u0026rsquo;: Creates a simple index.html file with the text \u0026ldquo;your very first web server\u0026rdquo; in the root document directory of the web server (/var/www/html). tags = { Name = \u0026ldquo;web-server\u0026rdquo; }: This line assigns a tag named \u0026ldquo;Name\u0026rdquo; with the value \u0026ldquo;web-server\u0026rdquo; to the server. "
},
{
	"uri": "//localhost:1313/3-explantion/",
	"title": "Initializing Resources",
	"tags": [],
	"description": "",
	"content": "Initializing Resources In this section, we initialize the necessary resources for the project, such as VPC, Subnet, Route table, etc., to deploy a Web Server using a Ubuntu virtual machine and apache2.\nContent Initialize VPC and configure connectivity Configure Security Group, Network Interface Configure Server "
},
{
	"uri": "//localhost:1313/1-introduce/1.3-resource/",
	"title": "Terraform Resource",
	"tags": [],
	"description": "",
	"content": "Terraform Resource In Terraform, a resource is a fundamental building block that makes up the infrastructure you manage with Terraform. It can consist of various types of resources, depending on the cloud provider you are using. They may include the following types of resources:\nVirtual Machines: EC2 instances on AWS, Azure VMs, Google Compute Engine. Networking: Includes VPC, subnet, load balancer, firewall. Storage: S3 buckets on AWS, Azure Blob Storage, Google Cloud Storage. Other Services: CloudWatch on AWS, Azure Monitor, Google Cloud Monitoring. Characteristics of Terraform Resources::\nDefined by Code: Utilizes the HashiCorp Configuration Language (HCL) to describe the desired configuration of resources. Lifecycle Management: Terraform can create, update, and delete resources automatically. Flexibility: Supports multiple cloud providers and can be used to manage on-premises infrastructure. Ease of Use: Provides simple and understandable syntax, making it easy to get started with. Syntax Usage:\nprovider \u0026#34;aws\u0026#34; {\rregion = \u0026#34;us-east-1\u0026#34;\r}\rresource \u0026#34;aws_instance\u0026#34; \u0026#34;example\u0026#34; {\rami = \u0026#34;ami-0c55b159cbfafe1f0\u0026#34; instance_type = \u0026#34;t2.micro\u0026#34; } In this example::\nprovider \u0026ldquo;aws\u0026rdquo;: specifies that we will use AWS as the service provider. resource \u0026ldquo;aws_instance\u0026rdquo; \u0026ldquo;example\u0026rdquo;: defines an EC2 resource named \u0026ldquo;example\u0026rdquo;. ami: Selects an Amazon Machine Image (AMI) to create the instance. instance_type: Selects the instance type, which here is t2.micro. There are several cloud service providers supported by Terraform. Make sure to choose the right provider for your needs.\n"
},
{
	"uri": "//localhost:1313/4-deloyws/",
	"title": "Deloy Web Server",
	"tags": [],
	"description": "",
	"content": "Deloy Web Server To run the project, after downloading the project file, unzip it anywhere you want. Then replace your access key and secret key in the provider block. Next, open the file using Visual Studio Code and press the Ctrl + Shift + ` key combination to open the Terminal. Enter terraform apply and then enter yes in the terminal to confirm the application of the configurations. . When the Terminal displays Apply completed and shows the Server_IP, it means Terraform has successfully deployed the infrastructure. Now, simply enter the IP address into any browser, and you should be able to access our Web Server. . . "
},
{
	"uri": "//localhost:1313/1-introduce/1.4-module/",
	"title": "Terraform Module",
	"tags": [],
	"description": "",
	"content": "Terraform Module A Terraform Module is a feature that allows you to divide Terraform code into smaller, more manageable parts. It\u0026rsquo;s similar to functions or classes in programming, helping to reuse code and organize infrastructure structure efficiently.\nBenefits of Using Terraform Modules::\nBenefits of Using Terraform Modules:: You can create modules for common infrastructure components, such as virtual machines, networks, or databases, and reuse them in multiple projects. Maintainability: Dividing code into smaller modules makes it easier to search, debug, and update code.un nhỏ giúp bạn dễ dàng tìm kiếm, sửa lỗi và cập nhật mã hơn. Collaboration: You can share modules with other members of your team to collaborate on developing and managing infrastructure together. *Example of a Terraform Module module \u0026#34;aws_ec2_instance\u0026#34; {\rsource = \u0026#34;hashicorp/aws/modules/ec2-instance\u0026#34;\rname = \u0026#34;my-instance\u0026#34;\rami = \u0026#34;ami-01234567890abcdef0\u0026#34;\rinstance_type = \u0026#34;t2.micro\u0026#34;\rcount = 2\r} This module can be used in any Terraform project to create an AWS EC2 virtual machine.\n"
},
{
	"uri": "//localhost:1313/1-introduce/1.5-state/",
	"title": "Terraform State",
	"tags": [],
	"description": "",
	"content": "Terraform State Terraform State is a data set that stores information about the infrastructure resources managed by Terraform. It includes:\nName and type of each resource. Attributes of each resource. Relationships between resources. Purposes:\nTrack changes to the infrastructure. Identify resources that need to be created, updated, or deleted. Keep your infrastructure consistent with Terraform configuration. Types of Terraform State::\nLocal State: Stored in a .tfstate file in your Terraform project directory. Remote State: Stored in remote storage repositories, such as HashiCorp Vault. **An example of information for an AWS virtual machine after it has been created **:\n{\r\u0026#34;resources\u0026#34;: {\r\u0026#34;aws_instance.web_server\u0026#34;: {\r\u0026#34;type\u0026#34;: \u0026#34;aws_instance\u0026#34;,\r\u0026#34;name\u0026#34;: \u0026#34;web_server\u0026#34;,\r\u0026#34;count\u0026#34;: 1,\r\u0026#34;primary\u0026#34;: {\r\u0026#34;id\u0026#34;: \u0026#34;i-1234567890abcdef0\u0026#34;,\r\u0026#34;attributes\u0026#34;: {\r\u0026#34;ami_id\u0026#34;: \u0026#34;ami-1234567890abcdef0\u0026#34;,\r\u0026#34;instance_type\u0026#34;: \u0026#34;t2.micro\u0026#34;,\r\u0026#34;public_ip\u0026#34;: \u0026#34;123.45.67.89\u0026#34;\r}\r}\r}\r}\r} There are several Terraform tools that can help you manage Terraform state, such as Terraform State Viewer and Terraform State Diff\n"
},
{
	"uri": "//localhost:1313/5-cleanup/",
	"title": "Clean Up",
	"tags": [],
	"description": "",
	"content": "Clean Up To clean up the resources in the Terminal of Visual Studio Code, enter terraform destroy, then enter yes to confirm. When the terminal shows Destroyed completed, it means Terraform has finished cleaning up the resources. "
},
{
	"uri": "//localhost:1313/2-prerequiste/2.3-profile/",
	"title": "",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "//localhost:1313/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "//localhost:1313/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]